READ MACRO
MOV AH,8
INT 21H
ENDM
PRINT MACRO CHAR
PUSH AX
PUSH DX
MOV DL,CHAR
MOV AH,02H
INT 21H
POP DX
POP AX
ENDM
PRINT_STRING MACRO STRING
PUSH AX
PUSH DX
MOV DX,OFFSET STRING
MOV AH,09H
INT 21H
POP DX
POP AX
ENDM
PRINT_NUM MACRO CHAR
MOV DL, CHAR
ADD DL, 30H
MOV AH, 2
INT 21H
ENDM
EXIT MACRO
MOV AH,4CH
INT 21H
ENDM
STACK_SEG SEGMENT STACK
DW 128 DUP(?)
ENDS
DATA_SEG SEGMENT
fin db "64.00$"
CONV DW 10
MED DW 0
IN_MSG DB "Give a 9-bit 2's complement number: $"
OUT_MSG DB "DECIMAL: $"
LINE DB 0AH,0DH,"$"
END1 DB "PRESS ANY KEY TO RESTART$"
DOT DB ".$"
POSITIVE DB "+$"
NEGATIVE DB "-$"
FIRS DB "75$"
SECON DB "50$"
THIRD DB "25$"
FOURTH DB "00$"
ENDS
CODE_SEG SEGMENT
ASSUME CS:CODE_SEG,SS:STACK_SEG, DS:DATA_SEG,ES:DATA_SEG
MAIN PROC FAR
;; SETTING OF SEGMENT REGISTERS
MOV AX,DATA_SEG
MOV DS,AX
MOV ES,AX
;; CODE PART
START:
PRINT_STRING IN_MSG
CALL BIN_9BIT_IN
PRINT_STRING LINE
PRINT_STRING OUT_MSG
CALL PRINT_DEC ;; NUMBER SHOULD BE PLACED
;; IN DX REGISTER
CON3:
PRINT_STRING LINE
PRINT_STRING END1
PRINT_STRING LINE
READ
JMP START
EXODOS:
EXIT
MAIN ENDP
;; ROUTINES PART
BIN_9BIT_IN PROC NEAR
MOV DX,0
MOV CX,9 ;; WE IN NEED FOR A
;; 9-TIME REPEATED LOOP
IGNORE:
READ ;; CHECK AX CHANGE
;; SET INPUT IN AL
;; AND RETURN DOS FUNCTION
;; CODE IN USING AH
CMP AL,'e'
JE check ;; FIRSTLY CHECK FOR
;; A POSSIBLE EXIT
CMP AL,'E'
JE check ;; KEEP CHECKING
CMP AL,30H
JL IGNORE
CMP AL,31H
JG IGNORE ;; IN CASE OF PASS
;; WE HAVE 0 OR 1
CMP CX,2
JE DOT1 ;; NEXT, PRINT THE DOT
CON:
PRINT AL
SUB AL,30H
MOV AH,0
ROL DX,1
ADD DX,AX
LOOP IGNORE ;; GET ALL 9 BITS USING
;; THE LOOP
RET
BIN_9BIT_IN ENDP
PRINT_DEC PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,DX ;; PLACE THE NUMBER IN AX
MOV MED,DX
AND DX,100H
CMP DX,100H
JE NEGATIV
PRINT_STRING POSITIVE
CON2:
ROR AX,2
AND AX,7FH
MOV BX,10 ;; PLACE DIVISOR IN BX
MOV CX,0 ;; COUNT THE NUMBER OF
;; DECIMAL DIGITS
AGAIN:
MOV DX,0
DIV BX ;; PLACE QUOTIENT IN AX
;; AND REMAINDER IN DX
PUSH DX
INC CX
CMP AX,0 ;; CHECK WHETHER
;; QUOTIENT == 0
;; AKA DIGITS ARE ALL STORED
;; IN THE STACK
JNE AGAIN
PRINT_LOOP:
POP DX
PRINT_NUM DL
LOOP PRINT_LOOP
POP DX
POP CX
POP BX
POP AX
CALL FRACTION
RET
PRINT_DEC ENDP
CHECK PROC NEAR
;; THIS FUNCTIO CHECKS WHETHER THE NEXT INPUT IS
;; EQAUL TO 1 IN ORDER TO MOVE ON TO THE NEXT CHECK
READ
CMP AL,30H
JL IGNORE
CMP AL,31H
JG IGNORE ;; BESIDES THAT WE SAVE AND
;; PRINT OUR INPUT, IN CASE
;; WE DO NOT HAVE TO EXIT
PRINT AL
SUB AL,30H
MOV AH,0
ROL DX,1
ADD DX,AX
dec cx
CMP AL,01H
JE check1
JMP IGNORE
CHECK ENDPcheck endp
CHECK1 PROC NEAR ;; OUR INPUT IS A CONTINUOUS
;; STRING => E1
READ
CMP AL,30H
JL IGNORE
CMP AL,31H
JG IGNORE
PRINT AL
SUB AL,30H
MOV AH,0 ;; IF WE HIT 1 WE HAVE
;; COMPLETED OUR FULL TEAM
;; NAME: E11 OR e11
ROL DX,1 ;; SO WE MUST EXIT, OTHERWISE
;; IN THE CASE WE DONT HAVE TO
;; EXIT, WE PRINT
ADD DX,AX ;; AND SAVE OUR INPUT
DEC CX
CMP AL,01H
JNE IGNORE
EXIT
CHECK1 ENDP
DOT1 PROC NEAR ;; WE PRINT THE DOT
PRINT_STRING DOT
JMP CON
FRACTION PROC NEAR
PRINT_STRING DOT
MOV DX,MED ;; WE TURN OUR FRACTION PART
;; INTO DECIMAL FORM
AND DX,03H
CMP DX,03H
JE FIR
CMP DX,02H
JE SEC
CMP DX,01H
JE THIR
CMP DX,00H
JE FOUR
RET
FRACTION ENDP
FIR PROC NEAR
PRINT_STRING FIRS
RET
FIR ENDP
SEC PROC NEAR
PRINT_STRING SECON
RET
SEC ENDP
THIR PROC NEAR
PRINT_STRING THIRD
RET
THIR ENDP
FOUR PROC NEAR
PRINT_STRING FOURTH
RET
FOUR ENDP
NEGATIV PROC NEAR
PRINT_STRING NEGATIVE
NOT AX ;; WE CREATE OUR NUMBER
;; IN CASE IT IS NEGATIVE
INC AX
MOV AH,00H
MOV MED,AX
CMP AX,00H
JE SPEC
JMP CON2
NEGATIV ENDP
SPEC PROC NEAR
PRINT_STRING FIN
JMP CON3
SPEC ENDP
CODE_SEG ENDS
END MAIN
